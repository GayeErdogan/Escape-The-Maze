module maze_game_with_uart (
    input clk,                 
    input uart_rx,             
    input [5:0] switches,      
    input mode_select,         
    output hsync,              
    output vsync,              
    output [3:0] r, g, b,      
    output reg [7:0] led,      
    output [6:0] seg,          
    output [3:0] anode         
);
 
    parameter CELL_SIZE = 32;       
    parameter GRID_WIDTH = 20;      
    parameter GRID_HEIGHT = 15;     

    reg [5:0] maze[0:299];          
    reg [4:0] player_x = 1;         
    reg [4:0] player_y = 1;         
    parameter goal_x = 18;          
    parameter goal_y = 13;          

    reg [31:0] timer_counter = 0;   
    reg [15:0] elapsed_seconds = 0; 
    reg game_completed = 1;        
    
    reg [9:0] h_count = 0;          
    reg [9:0] v_count = 0;          
    reg clk_25mhz = 0;              
    reg clk_50mhz = 0;


always @(posedge clk) begin
        clk_50mhz <= ~clk_50mhz;
    end
    
    always @(posedge clk_50mhz)begin
        clk_25mhz <= ~clk_25mhz;
    end
    always @(posedge clk_25mhz) begin
        if (h_count < 799)
            h_count <= h_count + 1;
        else begin
            h_count <= 0;
            if (v_count < 524)
                v_count <= v_count + 1;
            else
                v_count <= 0;
        end
    end

    assign hsync = (h_count >= 656 && h_count < 752);  
    assign vsync = (v_count >= 490 && v_count < 492);  


wire display_active = (h_count < 640 && v_count < 480);

assign r = (display_active && maze[(v_count / CELL_SIZE) * GRID_WIDTH + (h_count / CELL_SIZE)] == 1) ? 4'b1111 : 
           (display_active && h_count/CELL_SIZE == goal_x && v_count/CELL_SIZE == goal_y) ? 4'b0000 :
           (display_active && player_x == h_count/CELL_SIZE && player_y == v_count/CELL_SIZE) ? 4'b1111 : 4'b0000;

assign g = (display_active && maze[(v_count / CELL_SIZE) * GRID_WIDTH + (h_count / CELL_SIZE)] == 1) ? 4'b1111 : 
           (display_active && h_count/CELL_SIZE == goal_x && v_count/CELL_SIZE == goal_y) ? 4'b1111 :
           (display_active && player_x == h_count/CELL_SIZE && player_y == v_count/CELL_SIZE) ? 4'b0000 : 4'b0000;

assign b = (display_active && maze[(v_count / CELL_SIZE) * GRID_WIDTH + (h_count / CELL_SIZE)] == 1) ? 4'b1111 : 
           (display_active && h_count/CELL_SIZE == goal_x && v_count/CELL_SIZE == goal_y) ? 4'b0000 :
           (display_active && player_x == h_count/CELL_SIZE && player_y == v_count/CELL_SIZE) ? 4'b0000 : 4'b0000;


reg move_up = 0, move_down = 0, move_left = 0, move_right = 0;

    wire [7:0] uart_data;        
    wire uart_ready;             
    uart_receiver uart_rx_mod (
        .clk(clk),
        .rx(uart_rx),
        .data(uart_data),
        .data_ready(uart_ready)
    );

    always @(posedge clk) begin
        if (switches[5]) begin
            if (uart_ready) begin
                case (uart_data)
                    8'h57: move_up <= 1;   
                    8'h53: move_down <= 1;  
                    8'h41: move_left <= 1;  
                    8'h44: move_right <= 1; 
                    default: begin
                        move_up <= 0;
                        move_down <= 0;
                        move_left <= 0;
                        move_right <= 0;
                    end
                endcase
            end
        end
         else begin
            move_up <= switches[3];
            move_down <= switches[2];
            move_left <= switches[1];
            move_right <= switches[0];
        end
    end

always @(posedge clk) begin
    if(switches[4] & game_completed) begin
        player_x <= 1;
        player_y <= 1;
        game_completed <= 0;
        timer_counter <= 0;
        elapsed_seconds <= 0;
    end
    else begin
        if (!game_completed) begin
            if (move_up && maze[(player_y - 1) * GRID_WIDTH + player_x] == 0)
                player_y <= player_y - 1;
            else if (move_down && maze[(player_y + 1) * GRID_WIDTH + player_x] == 0)
                player_y <= player_y + 1;
            else if (move_left && maze[player_y * GRID_WIDTH + (player_x - 1)] == 0)
                player_x <= player_x - 1;
            else if (move_right && maze[player_y * GRID_WIDTH + (player_x + 1)] == 0)
                player_x <= player_x + 1;
                
            if (!switches[4]) begin
                timer_counter <= timer_counter + 1;
                if (timer_counter == 100000000) begin
                    elapsed_seconds <= elapsed_seconds + 1;
                    timer_counter <= 0;
                end
            end
            
            if (player_x == goal_x && player_y == goal_y)
                game_completed <= 1;
        end
    end
end

always @(posedge clk) begin
    led <= game_completed ? 8'b00001111 : 8'b11111111;
end


reg [15:0] display_value = 0;
    always @(posedge clk) begin
        if (game_completed)
            display_value <= elapsed_seconds;
        else
            display_value <= elapsed_seconds;
    end
    

    seven_segment_display_controller seg_ctrl (
        .clk(clk),
        .value(display_value),
        .seg(seg),
        .anode(anode)
    );


    maze[0]  = 1; maze[1]  = 1; maze[2]  = 1; maze[3]  = 1; maze[4]  = 1;
    maze[5]  = 1; maze[6]  = 1; maze[7]  = 1; maze[8]  = 1; maze[9]  = 1;
    maze[10] = 1; maze[11] = 1; maze[12] = 1; maze[13] = 1; maze[14] = 1;
    maze[15] = 1; maze[16] = 1; maze[17] = 1; maze[18] = 1; maze[19] = 1;

    maze[20] = 1; maze[21] = 0; maze[22] = 0; maze[23] = 0; maze[24] = 0;
    maze[25] = 0; maze[26] = 0; maze[27] = 0; maze[28] = 0; maze[29] = 1;
    maze[30] = 1; maze[31] = 1; maze[32] = 1; maze[33] = 1; maze[34] = 1;
    maze[35] = 1; maze[36] = 1; maze[37] = 1; maze[38] = 1; maze[39] = 1;

    maze[40] = 1; maze[41] = 0; maze[42] = 1; maze[43] = 1; maze[44] = 1;
    maze[45] = 0; maze[46] = 1; maze[47] = 1; maze[48] = 0; maze[49] = 0;
    maze[50] = 0; maze[51] = 0; maze[52] = 0; maze[53] = 0; maze[54] = 0;
    maze[55] = 0; maze[56] = 0; maze[57] = 0; maze[58] = 1; maze[59] = 1;

    maze[60] = 1; maze[61] = 0; maze[62] = 1; maze[63] = 0; maze[64] = 1;
    maze[65] = 0; maze[66] = 0; maze[67] = 0; maze[68] = 0; maze[69] = 1;
    maze[70] = 1; maze[71] = 1; maze[72] = 1; maze[73] = 1; maze[74] = 1;
    maze[75] = 1; maze[76] = 1; maze[77] = 0; maze[78] = 1; maze[79] = 1;

    maze[80] = 1; maze[81] = 0; maze[82] = 1; maze[83] = 0; maze[84] = 1;
    maze[85] = 1; maze[86] = 1; maze[87] = 1; maze[88] = 0; maze[89] = 1;
    maze[90] = 1; maze[91] = 0; maze[92] = 0; maze[93] = 0; maze[94] = 0;
    maze[95] = 0; maze[96] = 0; maze[97] = 0; maze[98] = 1; maze[99] = 1;

    maze[100] = 1; maze[101] = 0; maze[102] = 0; maze[103] = 0; maze[104] = 1;
    maze[105] = 0; maze[106] = 1; maze[107] = 1; maze[108] = 0; maze[109] = 1;
    maze[110] = 1; maze[111] = 0; maze[112] = 1; maze[113] = 1; maze[114] = 1;
    maze[115] = 1; maze[116] = 1; maze[117] = 0; maze[118] = 1; maze[119] = 1;

    maze[120] = 1; maze[121] = 1; maze[122] = 1; maze[123] = 0; maze[124] = 1;
    maze[125] = 0; maze[126] = 1; maze[127] = 1; maze[128] = 0; maze[129] = 1;
    maze[130] = 1; maze[131] = 0; maze[132] = 1; maze[133] = 0; maze[134] = 0;
    maze[135] = 0; maze[136] = 0; maze[137] = 0; maze[138] = 0; maze[139] = 1;

    maze[140] = 1; maze[141] = 1; maze[142] = 1; maze[143] = 0; maze[144] = 0;
    maze[145] = 0; maze[146] = 0; maze[147] = 0; maze[148] = 0; maze[149] = 0;
    maze[150] = 0; maze[151] = 0; maze[152] = 1; maze[153] = 1; maze[154] = 1;
    maze[155] = 1; maze[156] = 1; maze[157] = 0; maze[158] = 1; maze[159] = 1;

    maze[160] = 1; maze[161] = 1; maze[162] = 1; maze[163] = 0; maze[164] = 1;
    maze[165] = 1; maze[166] = 1; maze[167] = 1; maze[168] = 1; maze[169] = 1;
    maze[170] = 1; maze[171] = 1; maze[172] = 1; maze[173] = 1; maze[174] = 1;
    maze[175] = 1; maze[176] = 1; maze[177] = 0; maze[178] = 1; maze[179] = 1;

    maze[180] = 1; maze[181] = 1; maze[182] = 1; maze[183] = 0; maze[184] = 1;
    maze[185] = 1; maze[186] = 1; maze[187] = 1; maze[188] = 1; maze[189] = 0;
    maze[190] = 1; maze[191] = 1; maze[192] = 0; maze[193] = 0; maze[194] = 1;
    maze[195] = 1; maze[196] = 1; maze[197] = 0; maze[198] = 1; maze[199] = 1;
    maze[200] = 1; maze[201] = 1; maze[202] = 1; maze[203] = 0; maze[204] = 1;
    maze[205] = 1; maze[206] = 1; maze[207] = 0; maze[208] = 0; maze[209] = 0;
    maze[210] = 0; maze[211] = 0; maze[212] = 0; maze[213] = 1; maze[214] = 1;
    maze[215] = 1; maze[216] = 0; maze[217] = 0; maze[218] = 1; maze[219] = 1;
    maze[220] = 1; maze[221] = 1; maze[222] = 1; maze[223] = 0; maze[224] = 0;
    maze[225] = 0; maze[226] = 0; maze[227] = 0; maze[228] = 1; maze[229] = 1;
    maze[230] = 1; maze[231] = 1; maze[232] = 1; maze[233] = 1; maze[234] = 1;
    maze[235] = 0; maze[236] = 0; maze[237] = 1; maze[238] = 1; maze[239] = 1;
    maze[240] = 1; maze[241] = 1; maze[242] = 1; maze[243] = 1; maze[244] = 1;
    maze[245] = 1; maze[246] = 1; maze[247] = 0; maze[248] = 0; maze[249] = 0;
    maze[250] = 0; maze[251] = 0; maze[252] = 0; maze[253] = 0; maze[254] = 0;
    maze[255] = 0; maze[256] = 1; maze[257] = 1; maze[258] = 1; maze[259] = 1;
    maze[260] = 1; maze[261] = 1; maze[262] = 1; maze[263] = 1; maze[264] = 1;
    maze[265] = 1; maze[266] = 1; maze[267] = 1; maze[268] = 1; maze[269] = 1;
    maze[270] = 1; maze[271] = 1; maze[272] = 1; maze[273] = 1; maze[274] = 1;
    maze[275] = 0; maze[276] = 0; maze[277] = 0; maze[278] = 0; maze[279] = 1; 

    maze[280] = 1; maze[281] = 1; maze[282] = 1; maze[283] = 1; maze[284] = 1;
    maze[285] = 1; maze[286] = 1; maze[287] = 1; maze[288] = 1; maze[289] = 1;
    maze[290] = 1; maze[291] = 1; maze[292] = 1; maze[293] = 1; maze[294] = 1;
    maze[295] = 1; maze[296] = 1; maze[297] = 1; maze[298] = 1; maze[299] = 1;
    end

module uart_receiver (
    input clk,
    input rx,
    output reg [7:0] data,
    output reg data_ready
);
    parameter CLK_FREQ = 100000000;
    parameter BAUD_RATE = 9600;
    localparam BIT_PERIOD = CLK_FREQ / BAUD_RATE;

    reg [15:0] bit_counter = 0;
    reg [3:0] bit_index = 0;
    reg [9:0] rx_shift_reg = 10'b0;
    reg rx_sync = 1;
    reg rx_start = 0;

    always @(posedge clk) begin
        rx_sync <= rx;
        if (!rx_start && !rx_sync) begin
            rx_start <= 1;
            bit_counter <= BIT_PERIOD / 2;
            bit_index <= 0;
        end

        if (rx_start) begin
            if (bit_counter == BIT_PERIOD - 1) begin
                bit_counter <= 0;
                rx_shift_reg <= {rx_sync, rx_shift_reg[9:1]};
                bit_index <= bit_index + 1;

                if (bit_index == 9) begin
                    data <= rx_shift_reg[8:1];
                    data_ready <= 1;
                    rx_start <= 0;
                end
            end else begin
                bit_counter <= bit_counter + 1;
            end
        end else begin
            data_ready <= 0;
        end
    end
endmodule


module seven_segment_display_controller (
    input clk,
    input [15:0] value,
    output reg [6:0] seg,
    output reg [3:0] anode
);
    reg [3:0] digit;
    reg [19:0] refresh_counter = 0;
    reg [1:0] active_digit = 0;
    reg [7:0] minutes;
    reg [7:0] seconds;

    always @(*) begin
        minutes = value / 60;
        seconds = value % 60;
    end

    always @(posedge clk) begin
        refresh_counter <= refresh_counter + 1;
        if (refresh_counter == 50000) begin
            active_digit <= active_digit + 1;
            refresh_counter <= 0;
        end
    end

     always @(*) begin
        case (active_digit)
            2'b00: begin
                anode = 4'b1110;
                digit = seconds % 10;      
            end
            2'b01: begin
                anode = 4'b1101;
                digit = seconds / 10;      
            end
            2'b10: begin
                anode = 4'b1011;
                digit = minutes % 10;     
            end
            2'b11: begin
                anode = 4'b0111;
                digit = minutes / 10;      
            end
        endcase
    end

    always @(*) begin
        case (digit)
            4'b0000: seg = 7'b1000000;
            4'b0001: seg = 7'b1111001;
            4'b0010: seg = 7'b0100100;
            4'b0011: seg = 7'b0110000;
            4'b0100: seg = 7'b0011001;
            4'b0101: seg = 7'b0010010;
            4'b0110: seg = 7'b0000010;
            4'b0111: seg = 7'b1111000;
            4'b1000: seg = 7'b0000000;
            4'b1001: seg = 7'b0010000;
            default: seg = 7'b1111111;
        endcase
    end
endmodule


set_property PACKAGE_PIN W5 [get_ports clk]
set_property IOSTANDARD LVCMOS33 [get_ports clk]
create_clock -period 10.00 -name sys_clk_pin [get_ports clk]

set_property PACKAGE_PIN U2 [get_ports anode[0]]
set_property IOSTANDARD LVCMOS33 [get_ports anode[0]]
set_property PACKAGE_PIN U4 [get_ports anode[1]]
set_property IOSTANDARD LVCMOS33 [get_ports anode[1]]
set_property PACKAGE_PIN V4 [get_ports anode[2]]
set_property IOSTANDARD LVCMOS33 [get_ports anode[2]]
set_property PACKAGE_PIN W4 [get_ports anode[3]]
set_property IOSTANDARD LVCMOS33 [get_ports anode[3]]

set_property PACKAGE_PIN W7 [get_ports seg[0]]
set_property IOSTANDARD LVCMOS33 [get_ports seg[0]]
set_property PACKAGE_PIN W6 [get_ports seg[1]]
set_property IOSTANDARD LVCMOS33 [get_ports seg[1]]
set_property PACKAGE_PIN U8 [get_ports seg[2]]
set_property IOSTANDARD LVCMOS33 [get_ports seg[2]]
set_property PACKAGE_PIN V8 [get_ports seg[3]]
set_property IOSTANDARD LVCMOS33 [get_ports seg[3]]
set_property PACKAGE_PIN U5 [get_ports seg[4]]
set_property IOSTANDARD LVCMOS33 [get_ports seg[4]]
set_property PACKAGE_PIN V5 [get_ports seg[5]]
set_property IOSTANDARD LVCMOS33 [get_ports seg[5]]
set_property PACKAGE_PIN U7 [get_ports seg[6]]
set_property IOSTANDARD LVCMOS33 [get_ports seg[6]]

set_property PACKAGE_PIN U16 [get_ports led[0]]
set_property IOSTANDARD LVCMOS33 [get_ports led[0]]
set_property PACKAGE_PIN E19 [get_ports led[1]]
set_property IOSTANDARD LVCMOS33 [get_ports led[1]]
set_property PACKAGE_PIN U19 [get_ports led[2]]
set_property IOSTANDARD LVCMOS33 [get_ports led[2]]
set_property PACKAGE_PIN V19 [get_ports led[3]]
set_property IOSTANDARD LVCMOS33 [get_ports led[3]]
set_property PACKAGE_PIN W18 [get_ports led[4]]
set_property IOSTANDARD LVCMOS33 [get_ports led[4]]
set_property PACKAGE_PIN U15 [get_ports led[5]]
set_property IOSTANDARD LVCMOS33 [get_ports led[5]]
set_property PACKAGE_PIN U14 [get_ports led[6]]
set_property IOSTANDARD LVCMOS33 [get_ports led[6]]
set_property PACKAGE_PIN V14 [get_ports led[7]]
set_property IOSTANDARD LVCMOS33 [get_ports led[7]]

set_property PACKAGE_PIN V17 [get_ports switches[0]]
set_property IOSTANDARD LVCMOS33 [get_ports switches[0]]
set_property PACKAGE_PIN V16 [get_ports switches[1]]
set_property IOSTANDARD LVCMOS33 [get_ports switches[1]]
set_property PACKAGE_PIN W16 [get_ports switches[2]]
set_property IOSTANDARD LVCMOS33 [get_ports switches[2]]
set_property PACKAGE_PIN W17 [get_ports switches[3]]
set_property IOSTANDARD LVCMOS33 [get_ports switches[3]]
set_property PACKAGE_PIN R2 [get_ports switches[4]]
set_property IOSTANDARD LVCMOS33 [get_ports switches[4]]
set_property PACKAGE_PIN T1 [get_ports switches[5]]
set_property IOSTANDARD LVCMOS33 [get_ports switches[5]]

set_property -dict { PACKAGE_PIN B18   IOSTANDARD LVCMOS33 } [get_ports uart_rx]

set_property PACKAGE_PIN T18 [get_ports mode_select]
set_property IOSTANDARD LVCMOS33 [get_ports mode_select]

set_property PACKAGE_PIN P19 [get_ports hsync]
set_property IOSTANDARD LVCMOS33 [get_ports hsync]
set_property PACKAGE_PIN R19 [get_ports vsync]
set_property IOSTANDARD LVCMOS33 [get_ports vsync]

set_property PACKAGE_PIN N18 [get_ports {b[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports {b[0]}]
set_property PACKAGE_PIN L18 [get_ports {b[1]}]
set_property IOSTANDARD LVCMOS33 [get_ports {b[1]}]
set_property PACKAGE_PIN K18 [get_ports {b[2]}]
set_property IOSTANDARD LVCMOS33 [get_ports {b[2]}]
set_property PACKAGE_PIN J18 [get_ports {b[3]}]
set_property IOSTANDARD LVCMOS33 [get_ports {b[3]}]

set_property PACKAGE_PIN J17 [get_ports {g[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports {g[0]}]
set_property PACKAGE_PIN H17 [get_ports {g[1]}]
set_property IOSTANDARD LVCMOS33 [get_ports {g[1]}]
set_property PACKAGE_PIN G17 [get_ports {g[2]}]
set_property IOSTANDARD LVCMOS33 [get_ports {g[2]}]
set_property PACKAGE_PIN D17 [get_ports {g[3]}]
set_property IOSTANDARD LVCMOS33 [get_ports {g[3]}]

set_property PACKAGE_PIN G19 [get_ports {r[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports {r[0]}]
set_property PACKAGE_PIN H19 [get_ports {r[1]}]
set_property IOSTANDARD LVCMOS33 [get_ports {r[1]}]
set_property PACKAGE_PIN J19 [get_ports {r[2]}]
set_property IOSTANDARD LVCMOS33 [get_ports {r[2]}]
